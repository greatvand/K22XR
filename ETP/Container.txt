Container1, Container2, Container11, Container12

0. Ensure Docker Desktop is running
1. Import project in IDE
2. Open terminal inside IDE
3. docker compose up --build

Container3

1. Create SG - SSH (22)

Docker Swarm traffic (2377, 7946, 4789)

HTTP (80)

2. Launch 3 EC2 with user data

#!/bin/bash
sudo dnf install -y docker
sudo systemctl start docker
sudo systemctl enable docker
sudo usermod -aG docker ec2-user

3. Rename the VMs

4. Run in the manager

sudo docker swarm init --advertise-addr <Manager-Private-IP>

5. Run in the workers

sudo docker swarm join --token <token-id> <Manager-Private-IP>:2377

6. In Manager node, run

sudo docker node ls

Container4

1. Repeat the above steps

2. In Manager node, run 

sudo docker service create --name nginx-service --replicas 3 --publish 80:80 nginx:1.21

sudo docker service ps nginx-service

3. Check public ip

Container5 Container15

1. Repeat the above steps

2. sudo docker service update --image nginx:1.23 nginx-service

3. sudo docker service ps nginx-service

Container6

1. Create SG

SSH 22, TCP 30000â€“32767

2. Launch a medium EC2

3. Run the commands

sudo dnf install -y curl wget git conntrack bash-completion

sudo dnf install -y docker
sudo systemctl enable --now docker
sudo usermod -aG docker ec2-user
newgrp docker

curl -LO https://dl.k8s.io/release/v1.30.0/bin/linux/amd64/kubectl
chmod +x kubectl
sudo mv kubectl /usr/local/bin/
kubectl version --client

curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
chmod +x minikube-linux-amd64
sudo mv minikube-linux-amd64 /usr/local/bin/minikube
minikube version

minikube start --driver=docker
kubectl get nodes


vim nginx-pod.yaml

Press i

apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80

Press Escape -> Type :wq -> Press enter

kubectl apply -f nginx-pod.yaml
kubectl get pods
kubectl logs nginx-pod

Container7

1. Same steps till kubectl get nodes

2. vim nginx-deployment.yaml

Press i

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80

Press Escape -> Type :wq -> Press enter

kubectl apply -f nginx-deployment.yaml
kubectl get deployments
kubectl get pods

vim nginx-service.yaml

Press i

apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 80
    nodePort: 30080
  selector:
    app: nginx

Press Escape -> Type :wq -> Press enter

kubectl apply -f nginx-service.yaml
kubectl get svc
minikube service nginx-service --url
minikube ssh
curl http://192.168.49.2:30080

Container8

1. Same steps till kubectl get nodes

2. kubectl create deployment nginx-deploy --image=nginx --replicas=2

3. kubectl get pods -l app=nginx-deploy

4. kubectl scale deployment nginx-deploy --replicas=5

5. kubectl get pods -l app=nginx-deploy -w

6. kubectl scale deployment nginx-deploy --replicas=1

7. kubectl get pods -l app=nginx-deploy

Container9 Container 19

1. Same steps till kubectl get nodes

2. vim pv-pvc.yaml

Press i

apiVersion: v1
kind: PersistentVolume
metadata:
  name: demo-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data"
  persistentVolumeReclaimPolicy: Retain

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: demo-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 500Mi

Press Escape -> Type :wq -> Press enter

kubectl apply -f pv-pvc.yaml


vim pod-using-pvc.yaml

Press i

apiVersion: v1
kind: Pod
metadata:
  name: demo-pod
spec:
  containers:
    - name: busybox
      image: busybox
      command: ["/bin/sh", "-c", "while true; do sleep 30; done;"]
      volumeMounts:
        - mountPath: "/data"
          name: demo-storage
  volumes:
    - name: demo-storage
      persistentVolumeClaim:
        claimName: demo-pvc


Press Escape -> Type :wq -> Press enter

kubectl apply -f pod-using-pvc.yaml

kubectl exec -it demo-pod -- /bin/sh

echo "Hello from persistent storage" > /data/hello.txt
cat /data/hello.txt
exit

kubectl delete pod demo-pod
kubectl apply -f pod-using-pvc.yaml

kubectl exec -it demo-pod -- cat /data/hello.txt


Container10

1. Same steps till kubectl get nodes

2. kubectl create deployment web-app --image=nginx:1.19

kubectl get pods -l app=web-app

set image deployment/web-app nginx=nginx:1.21

kubectl describe deployment web-app | grep Image

kubectl rollout undo deployment/web-app

kubectl describe deployment web-app | grep Image

Container13

1. Same steps till Container3

2. docker network create -d overlay --attachable my-overlay

docker service create --name nginx-service --replicas 2 --network my-overlay nginx

docker service create --name alpine-service --replicas 1 --network my-overlay alpine sleep 1000

docker service ps alpine-service

Check the ip address and connect to that worker node

docker ps | grep alpine

Copy the container id

docker exec -it <container-di> sh

ping nginx-service

Container14

Open CMD

echo "mysecurepassword123" > db_password.txt

docker secret create db_password db_password.txt

docker secret ls

docker service create --name demo_secret_app --secret db_password alpine sh -c "while true; do cat /run/secrets/db_password; sleep 10; done"

docker service inspect demo_secret_app --pretty

docker service logs demo_secret_app


Container16

1. Same steps till kubectl get nodes

2. eval $(minikube docker-env)

vim Dockerfile

Press i

# Use the official NGINX base image
FROM nginx:latest

# Expose port 80 for HTTP traffic
EXPOSE 80

# Start NGINX server
CMD ["nginx", "-g", "daemon off;"]

Press Escape -> Type :wq -> Press enter

docker build -t my-nginx:latest .

vim nginx-deployment.yaml

Press i

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: my-nginx:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: ClusterIP


Press Escape -> Type :wq -> Press enter

kubectl apply -f nginx-deployment.yaml

kubectl get pods

kubectl logs <pod-id>


Container17

1. Same steps till kubectl get nodes

2. eval $(minikube docker-env)

3. vim Dockerfile

Press i

# Use the official NGINX base image
FROM nginx:latest

# Expose port 80 for HTTP traffic
EXPOSE 80

# Start NGINX server
CMD ["nginx", "-g", "daemon off;"]

Press Escape -> Type :wq -> Press enter

docker build -t my-nginx:latest .

vim backend.yaml

Press i

apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: nginx
        image: my-nginx:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: backend-svc
spec:
  selector:
    app: backend
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP

Press Escape -> Type :wq -> Press enter

kubectl apply -f backend.yaml


mkdir frontend
cd frontend

vim app.py

Press i

import http.client
from http.server import BaseHTTPRequestHandler, HTTPServer

class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        try:
            conn = http.client.HTTPConnection("backend-svc")
            conn.request("GET", "/")
            data = conn.getresponse().read().decode()[:100]
            conn.close()
            print(f"Backend response: {data}")
            self.send_response(200)
            self.end_headers()
            self.wfile.write(f"Got: {data}".encode())
        except Exception as e:
            print(f"Error: {e}")
            self.send_response(500)
            self.end_headers()
            self.wfile.write(f"Error: {e}".encode())

print("Starting server on port 8000")
HTTPServer(("", 8000), Handler).serve_forever()

Press Escape -> Type :wq -> Press enter

vim Dockerfile

Press i

FROM python:3.9-slim
COPY app.py .
EXPOSE 8000
CMD ["python", "app.py"]

Press Escape -> Type :wq -> Press enter

eval $(minikube docker-env)
docker build -t frontend:latest .

vim frontend.yaml


apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: frontend:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 8000
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-svc
spec:
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 8000
  type: ClusterIP

Press Escape -> Type :wq -> Press enter

kubectl apply -f frontend.yaml

kubectl port-forward service/frontend-svc 8080:80

Connect to the EC2 in a new window

curl http://localhost:8080


Container18

1. Same steps till kubectl get nodes

2. eval $(minikube docker-env)

3. vim Dockerfile

Press i

# Use the official NGINX base image
FROM nginx:latest

# Expose port 80 for HTTP traffic
EXPOSE 80

# Start NGINX server
CMD ["nginx", "-g", "daemon off;"]

Press Escape -> Type :wq -> Press enter

docker build -t my-nginx:latest .

vim nginx-configmap.yaml

Press i

apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  # Environment variables as key-value pairs
  APP_ENV: production
  LOG_LEVEL: info
  # Configuration file content
  nginx.conf: |
    server {
        listen 80;
        server_name localhost;
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
        location /configtest {
            return 200 "ConfigMap is working!";
        }
    }

Press Escape -> Type :wq -> Press enter

kubectl apply -f nginx-configmap.yaml

vim nginx-deployment-configmap.yaml

Press i

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-configmap-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx-configmap
  template:
    metadata:
      labels:
        app: nginx-configmap
    spec:
      containers:
      - name: nginx
        image: my-nginx:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 80
        env:
        - name: APP_ENV
          valueFrom:
            configMapKeyRef:
              name: nginx-config
              key: APP_ENV
        - name: LOG_LEVEL
          valueFrom:
            configMapKeyRef:
              name: nginx-config
              key: LOG_LEVEL
        volumeMounts:
        - name: config-volume
          mountPath: /etc/nginx/conf.d/custom.conf
          subPath: custom.conf
      volumes:
      - name: config-volume
        configMap:
          name: nginx-config
          items:
          - key: nginx.conf
            path: custom.conf
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-configmap-service
spec:
  selector:
    app: nginx-configmap
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: ClusterIP

Press Escape -> Type :wq -> Press enter

kubectl apply -f nginx-deployment-configmap.yaml

kubectl get pods
kubectl exec -it <pod-id> -- /bin/bash
env | grep -E 'APP_ENV|LOG_LEVEL'

Container20

Create docker-compose.yml

version: '3'
services:
  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: rootpass

  web:
    image: nginx
    ports:
      - "8080:80"


Create db-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: db
spec:
  replicas: 1
  selector:
    matchLabels:
      app: db
  template:
    metadata:
      labels:
        app: db
    spec:
      containers:
        - name: mysql
          image: mysql:5.7
          env:
            - name: MYSQL_ROOT_PASSWORD
              value: rootpass
          ports:
            - containerPort: 3306


Create db-service.yaml

apiVersion: v1
kind: Service
metadata:
  name: db
spec:
  selector:
    app: db
  ports:
    - port: 3306
      targetPort: 3306
  clusterIP: None  # Headless for internal communication


Create web-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: nginx
          image: nginx
          ports:
            - containerPort: 80


Create web-service.yaml

apiVersion: v1
kind: Service
metadata:
  name: web
spec:
  selector:
    app: web
  type: NodePort
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30080


kubectl apply -f db-deployment.yaml
kubectl apply -f db-service.yaml
kubectl apply -f web-deployment.yaml
kubectl apply -f web-service.yaml

kubectl get pods
kubectl get svc


minikube ip

curl ip:30080

